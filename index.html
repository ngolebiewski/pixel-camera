<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pixel Art Scanner</title>
<style>
  body {
    font-family: sans-serif;
    text-align: center;
    margin: 20px;
  }

  #camera-container {
    position: relative;
    width: 200px;
    height: 200px;
    display: inline-block;
    overflow: hidden; /* crop video top/bottom */
    border: 1px solid #ccc;
  }

  video {
    width: 200px;
    height: 200px;
    object-fit: cover; /* crop top/bottom to fit square */
  }

  canvas#grid {
    position: absolute;
    top: 0;
    left: 0;
    width: 200px;
    height: 200px;
    pointer-events: none; /* let buttons be clickable */
  }

  button {
    font-size: 16px;
    margin: 5px;
  }
</style>
</head>
<body>

<h2>üì∏ Pixel Art Scanner</h2>

<!-- Capture button at top -->
<button id="snap">üì∑ Capture Sprite</button>
<button id="startCam">‚ñ∂Ô∏è Start Camera</button>

<div id="camera-container">
  <video id="video" autoplay playsinline></video>
  <canvas id="grid" width="200" height="200"></canvas>
</div>

<script>
const video = document.getElementById('video');
const gridCanvas = document.getElementById('grid');
const gctx = gridCanvas.getContext('2d');

// Draw 16x16 grid overlay
function drawGrid() {
  const size = 16;
  const w = gridCanvas.width;
  const h = gridCanvas.height;
  gctx.clearRect(0, 0, w, h);
  gctx.strokeStyle = 'rgba(255,255,255,0.5)';
  gctx.lineWidth = 1;

  for (let i = 1; i < size; i++) {
    const x = (w / size) * i;
    const y = (h / size) * i;

    gctx.beginPath();
    gctx.moveTo(x, 0);
    gctx.lineTo(x, h);
    gctx.stroke();

    gctx.beginPath();
    gctx.moveTo(0, y);
    gctx.lineTo(w, y);
    gctx.stroke();
  }
}
drawGrid();

// Tap-to-start camera (required by Safari / Firefox)
async function startCamera() {
  if (video.srcObject) return;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: 'environment',
        width: { ideal: 400 },
        height: { ideal: 400 },
        aspectRatio: 1
      }
    });
    video.srcObject = stream;
  } catch (err) {
    alert(`Camera error:\n${err.name}\n${err.message}`);
  }
}
document.getElementById('startCam').onclick = startCamera;

// Auto-incrementing sprite filename
let spriteCount = Number(localStorage.getItem('spriteCount') || 1);

// Capture sprite function
document.getElementById('snap').onclick = () => {
  if (!video.videoWidth || !video.videoHeight) {
    alert("Video not ready yet!");
    return;
  }

  const spriteCanvas = document.createElement('canvas');
  spriteCanvas.width = 16;
  spriteCanvas.height = 16;
  const ctx = spriteCanvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  // Crop video to square (centered)
  const minDim = Math.min(video.videoWidth, video.videoHeight);
  const sx = (video.videoWidth - minDim) / 2;
  const sy = (video.videoHeight - minDim) / 2;

  ctx.drawImage(video,
    sx, sy, minDim, minDim, // source rectangle
    0, 0, 16, 16            // destination rectangle
  );

  // Make white pixels transparent (optional)
  const imgData = ctx.getImageData(0, 0, 16, 16);
  const data = imgData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i], g = data[i + 1], b = data[i + 2];
    if (r > 240 && g > 240 && b > 240) {
      data[i + 3] = 0;
    }
  }
  ctx.putImageData(imgData, 0, 0);

  // Save PNG
  const filename = `sprite_${String(spriteCount).padStart(3, '0')}.png`;
  spriteCount++;
  localStorage.setItem('spriteCount', spriteCount);

  spriteCanvas.toBlob(blob => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  });
};
</script>

</body>
</html>
